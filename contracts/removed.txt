from TokenMarketplace.sol

function buyTokens(address tokenAddress, address seller, uint256 amount) external payable {
        TokenListing storage listing = listings[tokenAddress][seller];
        require(listing.active, "Listing is not active");
        require(amount > 0, "Amount must be greater than 0");
        require(amount <= listing.availableTokens, "Not enough tokens available");
        
        // Calculate price
        uint256 totalPrice = listing.pricePerToken * amount;
        require(msg.value >= totalPrice, "Insufficient funds sent");
        
        // Transfer tokens from seller to buyer
        IERC20 token = IERC20(tokenAddress);
        bool success = token.transferFrom(seller, msg.sender, amount);
        require(success, "Token transfer failed");
        
        // Update listing
        listing.availableTokens -= amount;
        if (listing.availableTokens == 0) {
            listing.active = false;
        }
        
        // Transfer ETH to seller
        (bool sent, ) = payable(seller).call{value: totalPrice}("");
        require(sent, "Failed to send ETH to seller");
        
        // Refund excess ETH if any
        uint256 excess = msg.value - totalPrice;
        if (excess > 0) {
            (sent, ) = payable(msg.sender).call{value: excess}("");
            require(sent, "Failed to refund excess ETH");
        }
        
        emit TokensPurchased(tokenAddress, msg.sender, seller, amount, totalPrice);
    }



entire TokenMarketplace.sol:
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.21;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "./PropertyToken.sol";
import "hardhat/console.sol";

contract TokenMarketplace {
    // Token listing struct
    struct TokenListing {
        address tokenAddress;
        address seller;
        uint256 pricePerToken; // Price in wei per token
        uint256 availableTokens;
        bool active;
    }

    // Mapping from token address to seller address to listing
    mapping(address => mapping(address => TokenListing)) public listings;
    // Array to keep track of all listed tokens
    address[] public listedTokens;
    mapping(address => bool) private tokenExists;

    // Events
    event TokenListed(address indexed tokenAddress, address indexed seller, uint256 pricePerToken, uint256 amount);
    event ListingUpdated(address indexed tokenAddress, address indexed seller, uint256 pricePerToken, uint256 amount);
    event ListingCancelled(address indexed tokenAddress, address indexed seller);
    event TokensPurchased(
        address indexed tokenAddress, 
        address indexed buyer, 
        address indexed seller, 
        uint256 amount, 
        uint256 totalPrice
    );

    // List tokens for sale
    function listTokens(address tokenAddress, uint256 pricePerToken, uint256 amount) external {
        require(tokenAddress != address(0), "Invalid token address");
        require(pricePerToken > 0, "Price must be greater than 0");
        require(amount > 0, "Amount must be greater than 0");
        
        IERC20 token = IERC20(tokenAddress);
        
        // Check allowance
        uint256 allowance = token.allowance(msg.sender, address(this));
        require(allowance >= amount, "Not enough tokens approved for sale");
        
        // Check balance
        uint256 balance = token.balanceOf(msg.sender);
        require(balance >= amount, "Not enough tokens in your wallet");
        
        // If first time listing this token, add to array
        if (!tokenExists[tokenAddress]) {
            listedTokens.push(tokenAddress);
            tokenExists[tokenAddress] = true;
        }
        
        // Update or create listing
        listings[tokenAddress][msg.sender] = TokenListing({
            tokenAddress: tokenAddress,
            seller: msg.sender,
            pricePerToken: pricePerToken,
            availableTokens: amount,
            active: true
        });
        
        emit TokenListed(tokenAddress, msg.sender, pricePerToken, amount);
    }
    
    // Update token listing
    function updateListing(address tokenAddress, uint256 newPricePerToken, uint256 newAmount) external {
        TokenListing storage listing = listings[tokenAddress][msg.sender];
        require(listing.active, "No active listing found");
        require(listing.seller == msg.sender, "Not the seller");
        
        IERC20 token = IERC20(tokenAddress);
        
        // If increasing amount, check allowance and balance
        if (newAmount > listing.availableTokens) {
            uint256 additionalAmount = newAmount - listing.availableTokens;
            
            // Check allowance
            uint256 allowance = token.allowance(msg.sender, address(this));
            require(allowance >= additionalAmount, "Not enough tokens approved for sale");
            
            // Check balance
            uint256 balance = token.balanceOf(msg.sender);
            require(balance >= additionalAmount, "Not enough tokens in your wallet");
        }
        
        // Update listing
        listings[tokenAddress][msg.sender].pricePerToken = newPricePerToken;
        listings[tokenAddress][msg.sender].availableTokens = newAmount;
        
        emit ListingUpdated(tokenAddress, msg.sender, newPricePerToken, newAmount);
    }
    
    // Cancel a listing
    function cancelListing(address tokenAddress) external {
        TokenListing storage listing = listings[tokenAddress][msg.sender];
        require(listing.active, "No active listing found");
        require(listing.seller == msg.sender, "Not the seller");
        
        listing.active = false;
        listing.availableTokens = 0;
        
        emit ListingCancelled(tokenAddress, msg.sender);
    }
    
    // Buy tokens
    function buyTokens(address tokenAddress, address seller, uint256 amount) external payable {
        // Get the listing using the provided token address and seller address
        TokenListing storage listing = listings[tokenAddress][seller];

        // --- Pre-checks ---
        require(listing.active, "Listing is not active"); // Ensure the listing is still active
        require(amount > 0, "Amount must be greater than 0"); // Ensure buying a positive amount
        // Ensure the requested amount (in smallest units) is available in the listing
        require(amount <= listing.availableTokens, "Not enough tokens available in listing");

        // --- Get Token Details & Calculate Price ---
        // Cast the address to your specific PropertyToken contract type to access decimals()
        PropertyToken token = PropertyToken(tokenAddress);
        // Get the number of decimals for this specific token
        uint8 decimals = token.decimals();
        // Log decimals for debugging (visible in Hardhat console output)
        console.log("Contract buyTokens - Token Decimals:", decimals);

        // Calculate the total price correctly based on the listing's price per *whole* token
        // totalPrice (WEI) = (pricePerWholeToken (WEI) * amountInSmallestUnits) / (1 token in smallest units (10^decimals))
        // We need to be careful with potential division by zero if decimals is unexpectedly large, though unlikely for standard ERC20.
        uint256 decimalFactor = 10**decimals;
        require(decimalFactor > 0, "Decimal factor cannot be zero"); // Safety check
        uint256 totalPrice = (listing.pricePerToken * amount) / decimalFactor;

        // Log calculated price and received value for debugging
        console.log("Contract buyTokens - Listing Price/Token (WEI):", listing.pricePerToken);
        console.log("Contract buyTokens - Amount (Smallest Units):", amount);
        console.log("Contract buyTokens - Calculated Total Price (WEI):", totalPrice);
        console.log("Contract buyTokens - Received msg.value (WEI):", msg.value);

        // --- Check Funds Sent ---
        // Verify the buyer sent enough ETH to cover the calculated price
        require(msg.value >= totalPrice, "Insufficient funds sent");

        // --- Token Transfer ---
        // Log seller balance and marketplace allowance before attempting transfer (for debugging)
        console.log("Checking seller balance and allowance before transferFrom:");
        uint256 sellerBalance = token.balanceOf(seller);
        uint256 marketplaceAllowance = token.allowance(seller, address(this));
        console.log("   Seller Balance:", sellerBalance);
        console.log("   Marketplace Allowance:", marketplaceAllowance);
        console.log("   Amount to transfer:", amount);

        // Transfer the requested amount of tokens (in smallest units) from the seller to the buyer (msg.sender)
        // The marketplace contract needs prior approval from the seller to do this.
        bool success = token.transferFrom(seller, msg.sender, amount);
        require(success, "Token transfer failed"); // Revert if transfer fails
        console.log("Contract buyTokens - Token transfer successful.");

        // --- Update Listing State ---
        // Decrease the number of available tokens in the listing
        listing.availableTokens -= amount;
        // If no tokens are left, deactivate the listing
        if (listing.availableTokens == 0) {
            listing.active = false;
            console.log("Contract buyTokens - Listing deactivated (sold out).");
        } else {
             console.log("Contract buyTokens - Listing updated. Remaining available:", listing.availableTokens);
        }

        // --- ETH Payment to Seller ---
        // Transfer the calculated ETH price to the seller's address
        (bool sent, ) = payable(seller).call{value: totalPrice}("");
        require(sent, "Failed to send ETH to seller"); // Revert if ETH transfer fails
        console.log("Contract buyTokens - ETH sent to seller successfully.");


        // --- Refund Excess ETH ---
        // Calculate if the buyer sent more ETH than required
        uint256 excess = msg.value - totalPrice;
        if (excess > 0) {
            // If there's excess ETH, refund it to the buyer (msg.sender)
            console.log("Contract buyTokens - Refunding excess ETH:", excess);
            (sent, ) = payable(msg.sender).call{value: excess}("");
            // It's generally better not to revert on refund failure, but log it.
            // require(sent, "Failed to refund excess ETH");
             if (!sent) {
                  console.log("Warning: Failed to refund excess ETH to buyer.");
             }
        }

        // --- Emit Event ---
        // Notify listeners that a purchase occurred
        emit TokensPurchased(tokenAddress, msg.sender, seller, amount, totalPrice);
    }
    
    // Get all listed tokens
    function getAllListedTokens() external view returns (address[] memory) {
        return listedTokens;
    }
    
    // Get listing for a specific token and seller
    function getListing(address tokenAddress, address seller) external view returns (
        address, address, uint256, uint256, bool
    ) {
        TokenListing storage listing = listings[tokenAddress][seller];
        return (
            listing.tokenAddress,
            listing.seller,
            listing.pricePerToken,
            listing.availableTokens,
            listing.active
        );
    }
    
    // Check if a token is listed by any seller
    function isTokenListed(address tokenAddress) external view returns (bool) {
        return tokenExists[tokenAddress];
    }
}


Full old PropertyToken.sol:
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.21;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

contract PropertyToken is ERC20, Ownable {
    constructor(string memory name, string memory symbol, uint256 initialSupply, address owner)
        ERC20(name, symbol)
        Ownable(owner)
    {
        _mint(owner, initialSupply * (10 ** decimals()));
    }
}
